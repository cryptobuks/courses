import { __decorate } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import { isFunction, isNull, isString, isUndefined, } from '@roots/bud-support/lodash-es';
import { override } from './lifecycle/args.js';
import { bootstrap, LIFECYCLE_EVENT_MAP } from './lifecycle/bootstrap.js';
import * as parsers from './parsers/index.js';
import Value from './value.js';
/**
 * Framework abstract
 *
 * @public
 */
export class Bud {
    constructor() {
        this.services = [];
        this.json = parsers.json5;
        this.yml = parsers.yml;
        this.value = Value;
    }
    /**
     * Compilation mode
     *
     * @remarks
     * Either `production` or `development`.
     *
     * @readonly
     * @defaultValue `production`
     * @public
     */
    get mode() {
        return this.context.mode ?? `production`;
    }
    /**
     * Name
     *
     * @readonly
     * @public
     */
    get label() {
        return this.context.label;
    }
    /**
     * Parent {@link Bud} instance
     *
     * @readonly
     * @public
     */
    get root() {
        return this.context.root ?? this;
    }
    /**
     * True when {@link Bud.mode} is `production`
     *
     * @public
     */
    get isProduction() {
        return this.mode == `production`;
    }
    /**
     * True when {@link Bud.mode} is `development`
     *
     * @public
     */
    get isDevelopment() {
        return this.mode == `development`;
    }
    /**
     * True when current instance is the parent instance
     *
     * @readonly
     * @public
     */
    get isRoot() {
        return this.root.label === this.label;
    }
    /**
     * True when current instance is a child instance
     *
     * @readonly
     * @public
     */
    get isChild() {
        return this.root.label !== this.label;
    }
    /**
     * True when child compilers
     *
     * @readonly
     * @public
     */
    get hasChildren() {
        return (!isUndefined(this.children) &&
            !isNull(this.children) &&
            Object.entries(this.children).length > 0);
    }
    /**
     * Creates a child with `bud.create` but returns the parent instance
     *
     * @public
     */
    async make(request, tap) {
        if (!this.isRoot)
            return this.fatal(new Error(`Child instances should be produced from the root context`));
        let context = isString(request)
            ? { ...this.context, label: request, root: this }
            : { ...this.context, ...request, root: this };
        if (this.children && this.children[context.label]) {
            this.log(`returning requested child instance:`, context.label);
            return this.get(context.label);
        }
        this.log(`instantiating bud`, context);
        const child = await new Bud().lifecycle(context);
        if (!this.children)
            this.children = { [context.label]: child };
        else
            this.children[context.label] = child;
        if (tap)
            await tap(this.get(context.label));
        return this;
    }
    async lifecycle(context) {
        await bootstrap.bind(this)({ ...context });
        const logger = this.logger.instance.scope(...this.logger.scope, `bootstrap`);
        Object.entries(LIFECYCLE_EVENT_MAP).map(([eventHandle, callbackName]) => this.services
            .map(service => [service, this[service]])
            .map(([label, service]) => {
            if (!isFunction(service[callbackName]))
                return;
            this.hooks.action(eventHandle, service[callbackName].bind(service));
            logger.success(`registered service callback:`, `${label}.${callbackName}`);
        }));
        await [
            `init`,
            `bootstrap`,
            `bootstrapped`,
            `register`,
            `registered`,
            `boot`,
            `booted`,
        ].reduce(async (promised, event) => {
            await promised;
            try {
                await this.hooks
                    .fire(event)
                    .catch(error => logger.error(`error on`, event, error))
                    .finally(() => logger.success(event));
            }
            catch (error) {
                throw error;
            }
        }, Promise.resolve());
        this.hooks.action(`booted`, override);
        this.hooks.action(`build.before`, override);
        return this;
    }
    formatLogMessages(messages) {
        return messages.map(message => (typeof message !== `string`
            ? this.json.stringify(message)
            : message)
            ?.replaceAll(this.context.basedir, `.`)
            .replaceAll(/(.*)\s(.*)\/node_modules\/(.*)/g, `$1 $3`));
    }
    /**
     * Log a message
     *
     * @public
     * @decorator `@bind`
     */
    log(...messages) {
        if (!this.logger?.instance ||
            this.context.args.level?.length < 3 ||
            this.context.args.log === false)
            return this;
        this.logger.instance.log(...this.formatLogMessages(messages));
        return this;
    }
    /**
     * Log an `info` level message
     *
     * @public
     * @decorator `@bind`
     */
    info(...messages) {
        if (!this.logger?.instance ||
            this.context.args.level?.length < 4 ||
            this.context.args.log === false)
            return this;
        this.logger.instance.info(...this.formatLogMessages(messages));
        return this;
    }
    /**
     * Log a `success` level message
     *
     * @public
     * @decorator `@bind`
     */
    success(...messages) {
        if (!this.logger?.instance ||
            this.context.args.level?.length < 3 ||
            this.context.args.log === false)
            return this;
        this.logger.instance.success(...this.formatLogMessages(messages));
        return this;
    }
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    warn(...messages) {
        if (!this.logger?.instance)
            return this;
        this.logger.instance.warn(...this.formatLogMessages(messages));
        return this;
    }
    /**
     * Log an error.
     *
     * @remarks
     * In `production` this error is treated as fatal
     * and will kill the process.
     *
     * @public
     * @decorator `@bind`
     */
    error(...messages) {
        process.exitCode = 1;
        if (this.logger?.instance)
            this.logger.instance.error(...this.formatLogMessages(messages));
        return this;
    }
    /**
     * Log and display an error.
     *
     * @remarks
     * This will always kill the process
     *
     * @public
     * @decorator `@bind`
     * @throws fatal error
     */
    fatal(error) {
        process.exitCode = 1;
        this.logger.instance.error(error);
        throw error;
    }
}
__decorate([
    bind
], Bud.prototype, "lifecycle", null);
__decorate([
    bind
], Bud.prototype, "formatLogMessages", null);
__decorate([
    bind
], Bud.prototype, "log", null);
__decorate([
    bind
], Bud.prototype, "info", null);
__decorate([
    bind
], Bud.prototype, "success", null);
__decorate([
    bind
], Bud.prototype, "warn", null);
__decorate([
    bind
], Bud.prototype, "error", null);
__decorate([
    bind
], Bud.prototype, "fatal", null);
//# sourceMappingURL=bud.js.map