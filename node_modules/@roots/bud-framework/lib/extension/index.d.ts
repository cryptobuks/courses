import type { Signale } from 'signale';
import type { Compiler } from 'webpack';
import type { Bud } from '../bud.js';
import type { Modules } from '../types/registry/modules';
import type { ApplyPluginConstructor } from './decorators/plugin.js';
export declare type Options<T = Record<string, any>> = {
    [K in keyof T as `${K & string}`]?: T[K];
};
export declare type OptionsMap<MappedOptions extends Options> = {
    [K in keyof MappedOptions as `${K & string}`]?: ((app: Bud) => MappedOptions[K]) | MappedOptions[K];
};
/**
 * Webpack plugin.
 *
 * @public
 */
export interface ApplyPlugin {
    /**
     * Loose defined
     *
     * @public
     */
    [key: string]: any;
    /**
     * Apply callback
     *
     * @see {@link https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture}
     *
     * @public
     */
    apply: (...args: any[]) => unknown;
}
export interface Constructor {
    new (...args: [Bud]): Extension | ApplyPlugin;
}
export declare type ExtensionLiteral = {
    [K in keyof Extension]?: Extension[K];
};
/**
 * Bud extension
 *
 * @public
 */
export declare class Extension<ExtensionOptions extends Options = Options, Plugin extends ApplyPlugin = ApplyPlugin> {
    /**
     * Application
     *
     * @internal
     */
    _app: () => Bud;
    /**
     * Application accessor
     *
     * @public
     */
    app: Bud;
    /**
     * Extension options
     *
     * @internal
     */
    optionsMap: OptionsMap<ExtensionOptions>;
    /**
     * Extension options
     *
     * @readonly
     * @public
     */
    readonly options: ExtensionOptions;
    /**
     * Extension meta
     *
     * @public
     */
    meta: {
        init: boolean;
        register: boolean;
        boot: boolean;
        configAfter: boolean;
        buildBefore: boolean;
        buildAfter: boolean;
    };
    /**
     * The module name
     *
     * @public
     */
    label: keyof Modules & string;
    /**
     * @public
     */
    logger: Signale;
    /**
     * Depends on
     *
     * @public
     */
    dependsOn?: Set<`${keyof Modules & string}`>;
    /**
     * Depends on (optional)
     *
     * @public
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * Depends on (optional)
     *
     * @public
     */
    optIn?: Set<`${keyof Modules & string}`>;
    /**
     * Boolean or a function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * If a factory is implemented, it will be passed the {@link Bud} instance as its first parameter and
     * a {@link Container} instance holding the {@link Extension.options} (if any) as the second parameter.
     *
     * @public
     */
    when?(app: Bud, options?: ExtensionOptions): Promise<boolean>;
    /**
     * `init` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    init?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `register` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    register?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `boot` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    boot?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `configAfter` callback
     *
     * @public
     */
    configAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `buildBefore` callback
     *
     * @public
     */
    buildBefore?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `buildAfter` callback
     *
     * @public
     */
    buildAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    compilerBefore?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    compilerAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `make` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    make?(app: Bud, options?: ExtensionOptions): Promise<Plugin>;
    /**
     * Plugin constructor
     *
     * @public
     */
    plugin?: ApplyPluginConstructor;
    /**
     * Compiler plugin `apply` method
     *
     * @public
     */
    apply?(compiler: Compiler): unknown;
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app: Bud);
    /**
     * `init` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _init(): Promise<void>;
    /**
     * `register` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _register(): Promise<void>;
    /**
     * `boot` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _boot(): Promise<void>;
    /**
     * `buildBefore` callback handler
     *
     * @public
     */
    _buildBefore(): Promise<void>;
    /**
     * `buildAfter` callback handler
     *
     * @public
     */
    _buildAfter(): Promise<void>;
    /**
     * `configAfter` callback handler
     *
     * @public
     */
    _configAfter(): Promise<void>;
    /**
     * `make` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _make(): Promise<false | import("./decorators/plugin.js").ApplyPlugin | this>;
    /**
     * Get extension options
     *
     * @public
     * @decorator `@bind`
     */
    getOptions(): ExtensionOptions;
    /**
     * Set extension options
     *
     * @public
     * @decorator `@bind`
     */
    setOptions(value: ExtensionOptions | ((options: ExtensionOptions) => ExtensionOptions)): this;
    /**
     * Get extension option
     *
     * @public
     * @decorator `@bind`
     */
    getOption<K extends keyof ExtensionOptions & string>(key: K): ExtensionOptions[K];
    /**
     * Set extension option
     *
     * @public
     * @decorator `@bind`
     */
    setOption<K extends keyof ExtensionOptions & string>(key: K, value: ExtensionOptions[K]): this;
    /**
     * Normalize options to functions
     *
     * @public
     * @decorator `@bind`
     */
    toOptionsMap<K extends keyof ExtensionOptions & string>(funcMap: OptionsMap<ExtensionOptions>, [key, value]: [K & string, ExtensionOptions[K & string]]): OptionsMap<ExtensionOptions>;
    /**
     * Get options from function map
     *
     * @public
     * @decorator `@bind`
     */
    fromOptionsMap<K extends keyof OptionsMap<ExtensionOptions>>(options: ExtensionOptions, [key, value]: [K, OptionsMap<ExtensionOptions>[K]]): ExtensionOptions;
    /**
     * Assign properties from an object
     *
     * @public
     * @decorator `@bind`
     */
    fromObject(extensionObject: ExtensionLiteral): this;
    /**
     * Returns true if extension property is set
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    has<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Returns true if extension property is set and is a function
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    isFunction<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Resolve module using `import.meta.resolve` api
     *
     * @remarks
     * Uses `import-meta-resolve` (npm package).
     * Will transition to node `import.meta.resolve` api when it is marked
     * non-experimental. It currently requires a flag to enable.
     *
     * @public
     * @decorator `@bind`
     */
    resolve(signifier: string, context?: string): Promise<string>;
    /**
     * Import ESM module
     *
     * @public
     * @decorator `@bind`
     */
    import<T = any>(signifier: string): Promise<T>;
    /**
     * Disable extension
     *
     * @public
     * @decorator `@bind`
     */
    disable(): void;
    /**
     * Enable extension
     *
     * @public
     * @decorator `@bind`
     */
    enable(): void;
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     * @decorator `@bind`
     */
    isEnabled(): Promise<boolean>;
    /**
     * Alias for `.app`
     *
     * @remarks
     * Utility to make it easier to chain config fn calls
     *
     * @public
     * @decorator `@bind`
     */
    done(): Bud;
}
//# sourceMappingURL=index.d.ts.map