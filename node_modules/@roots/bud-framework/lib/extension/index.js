import { __decorate } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import { has, isBoolean, isFunction, isUndefined, } from '@roots/bud-support/lodash-es';
/**
 * Bud extension
 *
 * @public
 */
export class Extension {
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app) {
        /**
         * Extension options
         *
         * @internal
         */
        this.optionsMap = {};
        /**
         * Extension meta
         *
         * @public
         */
        this.meta = {
            init: false,
            register: false,
            boot: false,
            configAfter: false,
            buildBefore: false,
            buildAfter: false,
        };
        this._app = () => app;
        Object.defineProperty(this, `app`, {
            get: () => this._app(),
        });
        Object.defineProperty(this, `logger`, {
            get: () => app.logger.instance.scope(...this.app.logger.scope, this.label ?? `anonymous extension`),
        });
        const opts = this.options ?? {};
        Object.defineProperty(this, `options`, {
            get: this.getOptions,
            set: this.setOptions,
        });
        this.setOptions(opts);
    }
    /**
     * `init` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _init() {
        if (isUndefined(this.init))
            return;
        this.logger.log(`initialized`);
        try {
            await this.init(this.app, this.options);
            this.meta[`init`] = true;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `register` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _register() {
        if (isUndefined(this.register))
            return;
        this.logger.log(`registered`);
        if (this.init && !this.meta[`init`])
            await this._init();
        this.meta[`register`] = true;
        try {
            await this.register(this.app, this.options);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `boot` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _boot() {
        if (isUndefined(this.boot))
            return;
        if (this.init && !this.meta[`init`])
            await this._init();
        if (this.register && !this.meta[`register`])
            await this._register();
        this.logger.log(`booted`);
        try {
            await this.boot(this.app, this.options);
            this.meta[`boot`] = true;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `buildBefore` callback handler
     *
     * @public
     */
    async _buildBefore() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.buildBefore) || enabled === false)
            return;
        this.logger.log(`buildBefore`);
        this.meta[`buildBefore`] = true;
        await this.buildBefore(this.app, this.options);
    }
    /**
     * `buildAfter` callback handler
     *
     * @public
     */
    async _buildAfter() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.buildAfter) || enabled === false)
            return;
        this.logger.log(`buildAfter`);
        this.meta[`buildAfter`] = true;
        await this.buildAfter(this.app, this.options);
    }
    /**
     * `configAfter` callback handler
     *
     * @public
     */
    async _configAfter() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.configAfter) || enabled === false)
            return;
        await this.configAfter(this.app, this.options);
    }
    /**
     * `make` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _make() {
        this.logger.info(`trying to make`, this.label);
        if (isUndefined(this.make) &&
            isUndefined(this.apply) &&
            isUndefined(this.plugin)) {
            this.logger.info(`no make, apply or plugin prop found. skipping.`);
            return false;
        }
        const enabled = await this.isEnabled();
        if (enabled === false) {
            this.logger.info(`${this.label} is disabled. skipping.`);
            return false;
        }
        try {
            if (!isUndefined(this.apply)) {
                this.logger.info(`apply prop found. return extension instance`);
                return this;
            }
        }
        catch (error) {
            this.logger.error(`error instantiating plugin`, error);
        }
        try {
            if (!isUndefined(this.plugin)) {
                const plugin = new this.plugin(this.options);
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (err) {
            this.logger.error(`error instantiating plugin`, err);
        }
        try {
            if (!isUndefined(this.make)) {
                const plugin = await this.make(this.app, this.options);
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (err) {
            this.logger.error(`error calling make`, err);
        }
    }
    /**
     * Get extension options
     *
     * @public
     * @decorator `@bind`
     */
    getOptions() {
        return Object.entries(this.optionsMap ?? {}).reduce(this.fromOptionsMap, {});
    }
    /**
     * Set extension options
     *
     * @public
     * @decorator `@bind`
     */
    setOptions(value) {
        this.optionsMap = isFunction(value)
            ? value(this.options ?? {})
            : value;
        return this;
    }
    /**
     * Get extension option
     *
     * @public
     * @decorator `@bind`
     */
    getOption(key) {
        return this.options[key];
    }
    /**
     * Set extension option
     *
     * @public
     * @decorator `@bind`
     */
    setOption(key, value) {
        if (!this.optionsMap)
            this.optionsMap = {};
        this.optionsMap[key] = isFunction(value)
            ? value(this.options[key])
            : () => value;
        return this;
    }
    /**
     * Normalize options to functions
     *
     * @public
     * @decorator `@bind`
     */
    toOptionsMap(funcMap = {}, [key, value]) {
        return {
            ...funcMap,
            [key]: isFunction(value) ? value : () => value,
        };
    }
    /**
     * Get options from function map
     *
     * @public
     * @decorator `@bind`
     */
    fromOptionsMap(options, [key, value]) {
        return {
            ...(options ?? {}),
            [key]: isFunction(value) ? value(this.app) : value,
        };
    }
    /**
     * Assign properties from an object
     *
     * @public
     * @decorator `@bind`
     */
    fromObject(extensionObject) {
        Object.entries(extensionObject).map(([k, v]) => {
            this[k] = v;
        });
        return this;
    }
    /**
     * Returns true if extension property is set
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    has(key) {
        return has(this, key);
    }
    /**
     * Returns true if extension property is set and is a function
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    isFunction(key) {
        return this.has(key) && isFunction(this[key]) ? true : false;
    }
    /**
     * Resolve module using `import.meta.resolve` api
     *
     * @remarks
     * Uses `import-meta-resolve` (npm package).
     * Will transition to node `import.meta.resolve` api when it is marked
     * non-experimental. It currently requires a flag to enable.
     *
     * @public
     * @decorator `@bind`
     */
    async resolve(signifier, context) {
        let modulePath;
        modulePath = await this.app.module.resolve(signifier);
        if (!modulePath) {
            modulePath = await this.app.module.resolve(signifier, context);
        }
        if (!modulePath) {
            this.logger.error(`unresolvable:`, signifier);
        }
        return modulePath;
    }
    /**
     * Import ESM module
     *
     * @public
     * @decorator `@bind`
     */
    async import(signifier) {
        try {
            const path = await this.resolve(signifier);
            if (!path) {
                this.logger.error(`could not import`, signifier);
                return;
            }
            const result = await import(path);
            this.logger.success(`imported`, signifier);
            return result?.default ?? result ?? null;
        }
        catch (error) {
            this.logger.error(`error importing`, signifier);
        }
    }
    /**
     * Disable extension
     *
     * @public
     * @decorator `@bind`
     */
    disable() {
        this.when = async () => false;
    }
    /**
     * Enable extension
     *
     * @public
     * @decorator `@bind`
     */
    enable() {
        this.when = async () => true;
    }
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     * @decorator `@bind`
     */
    async isEnabled() {
        if (isUndefined(this.when))
            return true;
        if (isBoolean(this.when))
            return this.when;
        if (isFunction(this.when))
            return await this.when(this.app, this.options);
        return true;
    }
    /**
     * Alias for `.app`
     *
     * @remarks
     * Utility to make it easier to chain config fn calls
     *
     * @public
     * @decorator `@bind`
     */
    done() {
        return this.app;
    }
}
__decorate([
    bind
], Extension.prototype, "_init", null);
__decorate([
    bind
], Extension.prototype, "_register", null);
__decorate([
    bind
], Extension.prototype, "_boot", null);
__decorate([
    bind
], Extension.prototype, "_buildBefore", null);
__decorate([
    bind
], Extension.prototype, "_buildAfter", null);
__decorate([
    bind
], Extension.prototype, "_configAfter", null);
__decorate([
    bind
], Extension.prototype, "_make", null);
__decorate([
    bind
], Extension.prototype, "getOptions", null);
__decorate([
    bind
], Extension.prototype, "setOptions", null);
__decorate([
    bind
], Extension.prototype, "getOption", null);
__decorate([
    bind
], Extension.prototype, "setOption", null);
__decorate([
    bind
], Extension.prototype, "toOptionsMap", null);
__decorate([
    bind
], Extension.prototype, "fromOptionsMap", null);
__decorate([
    bind
], Extension.prototype, "fromObject", null);
__decorate([
    bind
], Extension.prototype, "has", null);
__decorate([
    bind
], Extension.prototype, "isFunction", null);
__decorate([
    bind
], Extension.prototype, "resolve", null);
__decorate([
    bind
], Extension.prototype, "import", null);
__decorate([
    bind
], Extension.prototype, "disable", null);
__decorate([
    bind
], Extension.prototype, "enable", null);
__decorate([
    bind
], Extension.prototype, "isEnabled", null);
__decorate([
    bind
], Extension.prototype, "done", null);
//# sourceMappingURL=index.js.map