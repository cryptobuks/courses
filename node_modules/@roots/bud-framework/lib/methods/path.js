import { join, normalize, resolve, sep } from 'node:path';
/**
 * Transform `@alias` path
 *
 * @param app - Bud instance
 * @param base - Path segment(s)
 * @returns string
 *
 * @public
 */
export const parseAlias = (app, ...base) => {
    /* Flatten and normalize input value */
    let [ident, ...parts] = base
        .map(path => (path.includes(sep) ? path.split(sep) : [path]))
        .flat();
    /* If there is no match for ident there is a problem */
    !app.hooks.hasSyncHook(`location.${ident}`) &&
        app.error(`\`${ident}\` is not a registered path`);
    /* Replace base path */
    ident = app.hooks.filter(`location.${ident}`);
    /* If segments were passed, resolve */
    return normalize(join(ident, ...(parts ?? [])));
};
export const path = function (base, ...segments) {
    const app = this;
    /* Exit early with context.basedir if no path was passed */
    if (!base)
        return app.context.basedir;
    const handles = (pathString) => pathString
        .replace(`@file`, app.hooks.filter(`feature.hash`)
        ? `[path][name].[contenthash:6][ext]`
        : `[path][name][ext]`)
        .replace(`@name`, app.hooks.filter(`feature.hash`)
        ? `[name].[contenthash:6][ext]`
        : `[name][ext]`);
    if (base === `@file` || base === `@name`)
        return handles(base);
    base = handles(base);
    segments = segments.map(handles);
    /* Parse `@` aliases. Should return an absolute path */
    if (base.startsWith(`@`))
        base = parseAlias(app, base);
    /* Resolve any base path that isn't already absolute */
    if (!base.startsWith(sep))
        base = resolve(app.context.basedir, base);
    /* If segments were passed, resolve them against base */
    return normalize(resolve(base, ...(segments ?? [])));
};
//# sourceMappingURL=path.js.map