import { __decorate } from "tslib";
import * as Service from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators';
import { isFunction, isUndefined } from '@roots/bud-support/lodash-es';
import * as items from './handlers/items.js';
import * as loaders from './handlers/loaders.js';
import * as rules from './handlers/rules/rules.js';
import Item from './item/item.js';
import Loader from './loader/loader.js';
import * as Rule from './rule/rule.js';
/**
 * Webpack configuration builder class
 *
 * @public
 */
export default class Build extends Service.Base {
    constructor() {
        super(...arguments);
        /**
         * @public
         */
        this.config = {};
        /**
         * Registered loaders
         *
         * @public
         */
        this.loaders = {};
        /**
         * Registered rules
         *
         * @public
         */
        this.rules = {};
        /**
         * Registered items
         *
         * @public
         */
        this.items = {};
    }
    /**
     * Make webpack configuration
     *
     * @public
     * @decorator `@bind`
     */
    async make() {
        this.app.log(`bud.build.make called`);
        try {
            await this.app.hooks.fire(`build.before`);
        }
        catch (error) {
            throw error;
        }
        await import(`./config/builder.js`).then(async (obj) => await Promise.all(Object.entries(obj).map(async ([prop, factory]) => {
            try {
                const value = await factory(this.app);
                if (isUndefined(value))
                    return;
                this.logger.success(`built`, prop);
                this.logger.info(value);
                this.config[prop] = value;
            }
            catch (error) {
                throw error;
            }
        })));
        this.logger.success(`configuration successfully built`);
        await this.app.hooks.fire(`build.after`);
        return this.config;
    }
    /**
     * Service register event
     *
     * @remarks
     * `loaders`, `items`, and `rules` are instantiated dumbly
     * because it is painful to think about how to map the typings..
     *
     * @public
     * @decorator `@bind`
     */
    async register() {
        Object.entries(loaders).map(([key, loaderFactory]) => {
            const value = loaderFactory(this.app);
            this.setLoader(key, value);
        });
        Object.entries(items).map(([key, itemFactory]) => {
            const value = itemFactory(this.app);
            this.setItem(key, value);
        });
        this.items.precss = this.app.isProduction
            ? this.items.minicss
            : this.items.style;
        Object.entries(rules)
            .reverse()
            .map(([key, ruleFactory]) => {
            this.setRule(key, ruleFactory(this.app));
        });
    }
    /**
     * Set Rule
     *
     * @param name - Rule key
     * @param options - Rule constructor properties
     * @returns the Rule
     *
     * @public
     * @decorator `@bind`
     */
    setRule(name, options) {
        if (options instanceof Rule.default) {
            this.rules[name] = options;
            this.logger.info(`set rule`, name, this.rules[name]);
            return this;
        }
        this.rules[name] = isFunction(options)
            ? options(this.makeRule())
            : this.makeRule(options);
        this.logger.info(`set rule`, name, this.rules[name]);
        return this;
    }
    /**
     * Make Rule
     *
     * @param options - rule constructor properties
     * @returns the rule
     *
     * @public
     * @decorator `@bind`
     */
    makeRule(options) {
        return new Rule.default(() => this.app, options);
    }
    getLoader(name) {
        if (!this.loaders[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.loaders[name];
    }
    /**
     * Set Loader
     *
     * @param name - Loader key
     * @param definition - Loader constructor properties
     * @returns the Loader
     *
     * @public
     * @decorator `@bind`
     */
    setLoader(name, definition) {
        const loader = isUndefined(definition)
            ? this.makeLoader(name)
            : definition instanceof Loader
                ? definition
                : this.makeLoader(definition);
        this.loaders[name] = loader;
        this.logger.info(`set loader`, loader);
        return this;
    }
    /**
     * Make Loader
     *
     * @param options - rule constructor properties
     * @returns the rule
     *
     * @public
     * @decorator `@bind`
     */
    makeLoader(src) {
        return new Loader(() => this.app, src);
    }
    getItem(name) {
        if (!this.items[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.items[name];
    }
    /**
     * Set Item
     *
     * @param name - Item key
     * @param options - Item constructor properties
     * @returns the Item
     *
     * @public
     * @decorator `@bind`
     */
    setItem(name, options) {
        const maybeOptionsCallback = isUndefined(options)
            ? { ident: name, loader: name }
            : options;
        const item = isFunction(maybeOptionsCallback)
            ? maybeOptionsCallback(this.makeItem())
            : this.makeItem(maybeOptionsCallback);
        this.items[name] = item;
        this.logger.info(`set item`, item);
        return this;
    }
    /**
     * Make Item
     *
     * @param options - rule constructor properties
     * @returns the rule
     *
     * @public
     * @decorator `@bind`
     */
    makeItem(options) {
        return new Item(() => this.app, options);
    }
}
/**
 * @public
 */
Build.label = `build`;
__decorate([
    bind
], Build.prototype, "make", null);
__decorate([
    bind
], Build.prototype, "register", null);
__decorate([
    bind
], Build.prototype, "setRule", null);
__decorate([
    bind
], Build.prototype, "makeRule", null);
__decorate([
    bind
], Build.prototype, "getLoader", null);
__decorate([
    bind
], Build.prototype, "setLoader", null);
__decorate([
    bind
], Build.prototype, "makeLoader", null);
__decorate([
    bind
], Build.prototype, "getItem", null);
__decorate([
    bind
], Build.prototype, "setItem", null);
__decorate([
    bind
], Build.prototype, "makeItem", null);
//# sourceMappingURL=service.js.map