import globby from '@roots/bud-support/globby';
import { isString } from '@roots/bud-support/lodash-es';
import { resolve } from 'import-meta-resolve';
import { dirname, join } from 'node:path/posix';
import { fileURLToPath } from 'node:url';
export class Commands {
    constructor(context, application) {
        this.context = context;
        this.application = application;
    }
    static get(application, context) {
        if (Commands.instance)
            return Commands.instance;
        else {
            Commands.instance = new Commands(context, application);
            return Commands.instance;
        }
    }
    async getCommands() {
        const resolvedExtensionPaths = await this.getRegistrationModulePaths();
        return resolvedExtensionPaths.filter(Boolean);
    }
    async getRegistrationModulePaths() {
        return await this.resolveExtensionCommandPaths(this.getProjectDependencySignifiers()).then(this.findExtensionCommandPaths);
    }
    /**
     * Get array of project dependency and devDependency signifiers
     */
    getProjectDependencySignifiers() {
        return Object.keys({
            ...(this.context.manifest?.dependencies ?? {}),
            ...(this.context.manifest?.devDependencies ?? {}),
        }).filter(signifier => !signifier.startsWith(`@types`));
    }
    /**
     * Find commands shipped with a given extension
     */
    async findExtensionCommandPaths(paths) {
        return await Promise.all(paths
            .map(dirname)
            .map(async (path) => globby(join(path, join(`bud`, `commands`, `index.js`))))).then(results => results.flat());
    }
    async resolveExtensionCommandPaths(paths) {
        return await Promise.all(paths.map(async (path) => {
            try {
                return resolve(path, import.meta.url);
            }
            catch (err) {
                console.warn(err);
                return false;
            }
        })).then(paths => paths.filter(isString).map(fileURLToPath));
    }
    /**
     * Import and register commands with the clipanion app
     */
    async registerExtensionCommandPaths(registerCallback) {
        try {
            await registerCallback(this.application);
        }
        catch (error) {
            console.warn(error);
        }
    }
    static async importCommandsFromPaths(paths) {
        try {
            return await Promise.all(paths.map(async (path) => {
                try {
                    return await import(path).then(({ default: register }) => register);
                }
                catch (error) {
                    throw new Error(error);
                }
            }));
        }
        catch (error) {
            console.warn(error);
        }
    }
}
//# sourceMappingURL=commands.js.map