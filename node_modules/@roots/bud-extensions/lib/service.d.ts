import type { ApplyPlugin, ExtensionLiteral } from '@roots/bud-framework/extension';
import { Extension } from '@roots/bud-framework/extension';
import type { Modules } from '@roots/bud-framework/registry/modules';
import { Base, Service } from '@roots/bud-framework/services/extensions';
/**
 * Extensions Service
 *
 * @public
 */
export default class Extensions extends Service {
    /**
     * Service label
     *
     * @public
     */
    static label: string;
    /**
     * Registered extensions
     *
     * @public
     */
    repository: Modules;
    /**
  -   * Modules on which an import attempt was made and failed
  -   *
  -   * @remarks
  -   * This doesn't mean an error, per se. This should only
  -   * be used in the context of trying to import `optionalDependencies`
  -   * of a given extension module.
  -   *
  -   * @public
  -   */
    unresolvable: Set<string>;
    /**
     * `booted` callback
     *
     * @public
     * @decorator `@bind`
     */
    booted(): Promise<void>;
    /**
     * `configAfter` callback
     *
     * @public
     * @decorator `@bind`
     */
    configAfter(): Promise<void>;
    /**
     * `buildBefore` callback
     */
    buildBefore(): Promise<void>;
    /**
     * `buildBefore` callback
     */
    buildAfter(): Promise<void>;
    /**
     * Has extension
     *
     * @public
     * @decorator `@bind`
     */
    has<K extends keyof Modules>(key: K & string): boolean;
    /**
     * Get extension
     *
     * @public
     * @decorator `@bind`
     */
    get<K extends keyof Modules>(key: K & string): Extension<import("@roots/bud-framework/extension").Options<Record<string, any>>, ApplyPlugin>;
    /**
     * Remove extension
     *
     * @public
     * @decorator `@bind`
     */
    remove<K extends keyof Modules>(key: K & string): this;
    /**
     * Set extension
     *
     * @public
     * @decorator `@bind`
     */
    set<K extends Modules>(value: Modules[K & string]): this;
    /**
     * Instantiate a Framework extension class or object
     *
     * @public
     * @decorator `@bind`
     */
    instantiate<K extends Modules>(extension: (new (...args: any[]) => Modules[K & string]) | ExtensionLiteral): Modules[K & string];
    filterApplicableExtensions(extensions: Array<string>): string[];
    /**
     * Import an extension
     *
     * @public
     * @decorator `@bind`
     */
    import(signifier: string, fatalOnError?: boolean): Promise<Extension>;
    /**
     * Add a {@link Extension} to the extensions repository
     *
     * @public
     * @decorator `@bind`
     */
    add(input: (new (...args: any[]) => Extension) | ExtensionLiteral | Array<(new (...args: any[]) => Extension) | ExtensionLiteral>): Promise<void>;
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `_init`
     * - `_register`
     * - `_boot`
     * - `_buildBefore`
     * - `_make`
     *
     * @public
     * @decorator `@bind`
     */
    run<K extends Modules>(extension: Modules[K & string], methodName: Base.LifecycleMethods): Promise<this>;
    /**
     * Execute a extension lifecycle method on all registered extensions
     *
     * @public
     * @decorator `@bind`
     */
    runAll(methodName: Base.LifecycleMethods): Promise<any>;
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     *
     * @public
     * @decorator `@bind`
     */
    runDependencies<K extends Modules>(extension: Modules[K & string] | (keyof Modules & string), methodName: Base.LifecycleMethods): Promise<void>;
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     *
     * @public
     * @decorator `@bind`
     */
    make(): Promise<ApplyPlugin[]>;
    protected isOptedIn(signifier: string): boolean;
}
//# sourceMappingURL=service.d.ts.map