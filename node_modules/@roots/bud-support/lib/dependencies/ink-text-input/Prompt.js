import chalk from 'chalk';
import { Text, useInput } from 'ink';
import React from 'react';
import { highlight } from '../../highlight/index.js';
const Prompt = ({ value: originalValue, placeholder = ``, focus = true, mask, showCursor = true, onChange, onSubmit, }) => {
    const [{ cursorOffset }, setState] = React.useState({
        cursorOffset: (originalValue || ``).length,
        cursorWidth: 0,
    });
    React.useEffect(() => {
        setState(previousState => {
            if (!focus || !showCursor) {
                return previousState;
            }
            const newValue = originalValue || ``;
            if (previousState.cursorOffset > newValue.length - 1) {
                return {
                    cursorOffset: newValue.length,
                    cursorWidth: 0,
                };
            }
            return previousState;
        });
    }, [originalValue, focus, showCursor]);
    const value = mask ? mask.repeat(originalValue.length) : originalValue;
    let renderedPlaceholder = placeholder
        ? chalk.grey(placeholder)
        : undefined;
    useInput((input, key) => {
        if (key.upArrow ||
            key.downArrow ||
            (key.ctrl && input === `c`) ||
            key.tab ||
            (key.shift && key.tab)) {
            return;
        }
        if (key.return) {
            if (onSubmit) {
                onSubmit(originalValue);
            }
            return;
        }
        let nextCursorOffset = cursorOffset;
        let nextValue = originalValue;
        let nextCursorWidth = 0;
        if (key.leftArrow) {
            if (showCursor) {
                nextCursorOffset--;
            }
        }
        else if (key.rightArrow) {
            if (showCursor) {
                nextCursorOffset++;
            }
        }
        else if (key.backspace || key.delete) {
            if (cursorOffset > 0) {
                nextValue =
                    originalValue.slice(0, cursorOffset - 1) +
                        originalValue.slice(cursorOffset, originalValue.length);
                nextCursorOffset--;
            }
        }
        else {
            nextValue =
                originalValue.slice(0, cursorOffset) +
                    input +
                    originalValue.slice(cursorOffset, originalValue.length);
            nextCursorOffset += input.length;
            if (input.length > 1) {
                nextCursorWidth = input.length;
            }
        }
        if (cursorOffset < 0) {
            nextCursorOffset = 0;
        }
        if (cursorOffset > originalValue.length) {
            nextCursorOffset = originalValue.length;
        }
        setState({
            cursorOffset: nextCursorOffset,
            cursorWidth: nextCursorWidth,
        });
        if (nextValue !== originalValue) {
            onChange(nextValue);
        }
    }, { isActive: focus });
    return (React.createElement(Text, null, placeholder
        ? value.length > 0
            ? highlight(`async (bud: Bud) => ${value}`)
            : renderedPlaceholder
        : highlight(`async (bud: Bud) => ${value}`)));
};
export { Prompt };
//# sourceMappingURL=Prompt.js.map