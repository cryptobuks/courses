import { __decorate } from "tslib";
import RefreshPlugin from '@pmmmwh/react-refresh-webpack-plugin';
import { Extension } from '@roots/bud-framework/extension';
import { bind, development, label, options, plugin, } from '@roots/bud-framework/extension/decorators';
import { isBoolean, isUndefined } from '@roots/bud-support/lodash-es';
/**
 * Wrapper for `@pmmmwh/react-refresh-webpack-plugin`
 *
 * @remarks
 * Does not execute if `bud.mode` is not `development`
 *
 * @public
 * @decorator `@label`
 * @decorator `@plugin`
 * @decorator `@options`
 * @decorator `@development`
 */
let BudReactRefresh = class BudReactRefresh extends Extension {
    /**
     * Set extension to handle react-refresh code transforms
     *
     * @public
     */
    setTransformExtension(extension) {
        this.transformExtension = extension;
    }
    /**
     * `configAfter` callback
     *
     * @public
     * @decorator `@bind`
     */
    async configAfter() {
        this.logger.log(`Injecting react-refresh/client scripts`);
        if (!this.app.hasChildren)
            this.app.hooks.on(`dev.client.scripts`, scripts => scripts
                ? scripts.add(() => `react-refresh/runtime`)
                : new Set([() => `react-refresh/runtime`]));
        else
            Object.values(this.app.children).forEach(instance => instance.hooks.on(`dev.client.scripts`, scripts => scripts
                ? scripts.add(() => `react-refresh/runtime`)
                : new Set([() => `react-refresh/runtime`])));
        if (!this.transformExtension) {
            const signifier = this.app.react.useBabel
                ? `@roots/bud-react/babel-refresh`
                : this.app.extensions.has(`@roots/bud-swc`)
                    ? `@roots/bud-react/swc-refresh`
                    : `@roots/bud-react/typescript-refresh`;
            const transformExtension = await this.import(signifier);
            await this.app.extensions.add(transformExtension);
            this.setTransformExtension(this.app.extensions.get(signifier));
        }
        this.logger.log(`Registering transformer`, this.transformExtension.label);
    }
    /**
     * Configure react-refresh-webpack-plugin
     *
     * @example
     * Add react-refresh-webpack-plugin
     *
     * ```ts
     * bud.react.refresh(true)
     * ```
     *
     * @example
     * Remove react-refresh-webpack-plugin
     *
     * ```ts
     * bud.react.refresh(false)
     * ```
     *
     * @example
     * Configure react-refresh-webpack-plugin
     *
     * ```ts
     * bud.react.refresh({
     *   overlay: true,
     * })
     * ```
     *
     * @remarks
     * Configuration takes place during the `config.after` event
     *
     * @public
     * @decorator `@bind`
     */
    configure(userOptions) {
        this.app.hooks.action(`config.after`, this.makeReactRefreshCallback(userOptions));
        return this;
    }
    /**
     * Callback handling react-refresh-webpack-plugin configuration
     *
     * @public
     * @decorator `@bind`
     */
    makeReactRefreshCallback(userOptions) {
        return async () => {
            if (!this.app.isDevelopment)
                return;
            userOptions === false ? this.disable() : this.enable();
            if (isUndefined(userOptions) || isBoolean(userOptions))
                return;
            this.setOptions(userOptions);
            return this;
        };
    }
};
__decorate([
    bind
], BudReactRefresh.prototype, "configAfter", null);
__decorate([
    bind
], BudReactRefresh.prototype, "configure", null);
__decorate([
    bind
], BudReactRefresh.prototype, "makeReactRefreshCallback", null);
BudReactRefresh = __decorate([
    label(`@roots/bud-react/react-refresh`),
    plugin(RefreshPlugin),
    options({ overlay: false }),
    development
], BudReactRefresh);
export default BudReactRefresh;
//# sourceMappingURL=extension.js.map