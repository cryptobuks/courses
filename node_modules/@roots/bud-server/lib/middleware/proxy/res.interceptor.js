import { __decorate } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import { isString, isUndefined } from '@roots/bud-support/lodash-es';
import { responseInterceptor } from 'http-proxy-middleware';
/**
 * Proxy response interceptor
 *
 * @public
 */
export class ResponseInterceptorFactory {
    /**
     * Class constructor
     *
     * @public
     */
    constructor(_app, url) {
        this._app = _app;
        this.url = url;
    }
    /**
     * The bud instance
     *
     * @public
     */
    get app() {
        return this._app();
    }
    /**
     * Response interceptor
     *
     * @remarks
     * This is the callback for `http-proxy-middleware`s `responseInterceptor`.
     * It is called after the response has been received from the target server.
     * It is passed the response body, and the req and res objects.
     * It can be used to modify the response body or the response object.
     *
     * @param buffer - Buffered response
     * @param proxyResponse - Response from the proxy
     * @param request - Request from the client
     * @param response - Response from the server
     *
     * @public
     * @decorator `@bind`
     */
    async interceptor(buffer, proxyResponse, request, response) {
        this.app.info(request.url, request.statusCode, response.getHeader(`content-type`));
        if (!`${response.getHeader(`content-type`)}`.startsWith(`text/`))
            return buffer;
        Object.entries(this.app.hooks.filter(`dev.middleware.proxy.options.headers`, {
            ...response.getHeaders(),
            'x-proxy-by': `@roots/bud`,
            'x-bud-dev-origin': this.url.dev.origin,
            'x-bud-dev-protocol': this.url.dev.protocol,
            'x-bud-dev-hostname': this.url.dev.hostname,
            'x-bud-proxy-origin': this.url.proxy.origin,
            'content-security-policy': undefined,
            'x-http-method-override': undefined,
        })).map(([k, v]) => {
            if (isString(k) && isUndefined(v)) {
                this.app.log(`removing header`, k);
                response.removeHeader(k);
            }
            else if (isString(k) && !isUndefined(v)) {
                this.app.log(`setting header`, k, `=>`, v);
                response.setHeader(k, v);
            }
        });
        Object.entries(request.cookies).map(([k, v]) => {
            this.app.info(`setting cookie`, k, `=>`, v);
            response.cookie(k, v, { domain: undefined });
        });
        return this.app.hooks
            .filter(`dev.middleware.proxy.replacements`, [])
            .reduce((buffer, [search, replace]) => buffer
            .split(`\n`)
            .map((ln) => ln.replaceAll(search, replace))
            .join(`\n`), buffer.toString());
    }
    /**
     * Returns the `onProxyRes` callback for `http-proxy-middleware`
     *
     * @public
     * @decorator `@bind`
     */
    make() {
        return responseInterceptor(this.interceptor);
    }
}
__decorate([
    bind
], ResponseInterceptorFactory.prototype, "interceptor", null);
__decorate([
    bind
], ResponseInterceptorFactory.prototype, "make", null);
